/*
  Touch Range to PWM Range & MIDI over Bluetooth

  Maps capacitance on touch pin T7 to an audible tone frequency. You first need 
  to figure out what the touch value range is by touching/squeezing/stretching and releasing 
  the touch pin and reading the values in the serial monitor. Change 
  the threshold accordingly.
  
  Connect + of the speaker to pin D7
  Connect - of the speaker to GND
  Connect a touch sensor to pin T1, T2, T3, T4, T5, T6 (with an alligator clip for example)

  made 18 Oct 2024
  by Michelle Vossen

  This example code is in the public domain.

  https://v0ss3n.github.io/projects/education/wearables 
*/

#include "pitches.h"
#include <BLEMIDI_Transport.h>       //BLE MIDI Transport library
#include <hardware/BLEMIDI_ESP32.h>  //BLE ESP32 library

BLEMIDI_CREATE_INSTANCE("MichSynth", MIDI);  //make instance of BLEMIDI

//variables
int midiNote;
int btnState;
int lastBtnState;
int speaker_pin = D7;  // Pin the speaker is attached to
int analog_pin = A10;  // Pin the speaker is attached to

// variables for storing the touch pins, values and thresholds. change threshold if needed
int touch_pins[] = { T1, T2, T3, T4, T5, T6, T7, T8 };  // Pin that we're going to touch
int touchValues[] = { 0, 0, 0, 0, 0, 0, 0, 0 };
int thresholds[] = { 100000, 100000, 100000, 100000, 100000, 100000, 100000, 100000 };
int pitches[] = { NOTE_A3, NOTE_B3, NOTE_C3, NOTE_D3, NOTE_E3, NOTE_F3, NOTE_F4, NOTE_A4 };

// int touch_pin = T7;  // Pin that we're going to touch > range
int pitch;

// variable for storing the touch pin value and threshold. change threshold if needed
int touchValue;
int threshold = 75000;  // threshold

// the setup function runs once when you press reset or power the board
void setup() {
  // initialize serial communication at 115200 bits per second:
  Serial.begin(115200);
  // initialize LED_pin as an output
  pinMode(speaker_pin, OUTPUT);

  MIDI.begin();  //start MIDI
}

// the loop function runs over and over again forever
void loop() {
  Serial.println("Touch values:");
  for (int i = 0; i < 8; i++) {
    touchValues[i] = touchRead(touch_pins[i]);
    Serial.println(touchValues[i]);
    if (touchValues[i] > thresholds[i]) {
      Serial.print("Pin touched: ");
      Serial.println(touch_pins[i]);
    // constrain touchValue range for useful pitch generation
      touchValue = constrain(touchValues[i], 50000, 200000);
      pitch = map(touchValue, 50000, 200000, 31, 2000);  // set max pitch to 2000 to avoid errors with ledc timer

      tone(speaker_pin, pitch);

      // tone(speaker_pin, pitches[i]);
      Serial.print("Pitches number: ");
      Serial.println(pitches[i]);
    } else {
      noTone(speaker_pin);  // Stop tone when under threshold

    }

    // // Play tone if touchValue exceeds threshold
    // if (touchValue > threshold) {
    //   // tone(speaker_pin, pitch);
    //   midiNote = map(touchValue, 75000, 200000, 21, 88);
    //   MIDI.sendNoteOn(midiNote, 127, 1);
    // } else {
    //   // noTone(speaker_pin);  // Stop tone when under threshold
    //   MIDI.sendNoteOff(midiNote, 0, 1);
    // }


    delay(50);
  }
}



// void loop() {
//   midiNote = map(analogRead(potPin), 0, 4096, 60, 80);  //read potPin and remap value to range of 60 to 80

//   lastBtnState = btnState;            //reset lastBtnState to equal current btnState
//   btnState = digitalRead(buttonPin);  //assign read voltage state to btnState

//   //trigger a note
//   if (lastBtnState == 1 && btnState == 0) {  //if there is a difference between last button state and current button state
//     MIDI.sendNoteOn(midiNote, 127, 1);       //send MIDI note generated by pot position
//   }
// }
